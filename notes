Ep2 learnings:

- npm => fullform is not Node Package Manager, but it is one.
- caret(^) vs tilde(~)
- package.json vs package-lock.json
- node_modules?
- transitive dependencies?
- no to putting node_modules on git, yes to putting package.json & package-lock.json on git
- npx(execute a package) vs npm(for installing a package)
- We can also use React in our project using npm
- The way to use React via CDN links is not the preferred way.

Ep3 learnings:

- Instead of calling npx parcel index.html, write the script in package.json
- npm start = npm run start
- Writing react code in .js file isn't making out lived easier. So they came up with JSX.
- Note that JSX is not a part of react or it is not the case that react can't be written w/o JSX.
- JSX = JS + HTML
- Now many think that jsx is nothing but html inside js, but it is not true. JSX is not html, it is an html-like syntax.
- JSX code is first converted to React Element(which is an object) which is then converted to html element.
- The task of converting jsx to react element is done by Babel (a transpiler or JS compiler). Parcel gives the responsibility of transpilation to Babel.
- Babel is not created by Facebook.
- The JS engine does not understand JSX because the JS engine understands ECMAScript or ES6+ code.
- Before the code gets to JS Engine it is sent to Parcel and Transpiled there.
- Transpilation â‡’ Converting the code in such a format that the browsers can understand.
- In JSX, attributes are given in Camel-case!
- Components in React => two types = Class-based(OLD way) and Functional(NEW way)
- A Functional Component is a function that "returns" some React element/JSX code.
- When we use one React component into another React Component, it is called Component Composition.
- Any JS expression can be written inside a Component by covering it inside a {}.
- If you want to use a component inside another component/element, use <Component /> or {Component()} and if you want to use an elemtent inside a component/element, use {Element}.
- <Component /> = <Component></Component>
- Also, JSX sanitises whatever info we bring under {} instead of blindly passing it further. Hence, it also checks Cross Site Scripting.

Ep4 Learnings:

- The best way in approaching any project is to plan first. Hence, planning is essential.
- 1st step of planning = creating a wireframe or UI design or layout.
- whatever properties are passed to the component, becomes a prop.
- "Destructuring on the Fly" - doing the same thing but without the word 'prop'.
- Passing props to a function is primarily a React concept, although it is built on JavaScript's ability to pass arguments to functions.
- "Destr. on the Fly" is a JS thing, not limited to just React.
- "Config-driven UI" refers to a design approach where the user interface (UI) is generated or configured based on external configuration data, rather than being hardcoded or statically defined in the application code.
- "Optional Chaining" = "?." => a feature introduced in JavaScript (ES2020) that helps to avoid runtime errors when trying to access properties on objects that may not exist, preventing you from writing multiple checks for each level.
- Whenever you're mapping through an Array (using Array.map), always pass a "key" unique to each of the item.
- The logic behind giving a key to each of the Array object, is because once a new entrant is there, unless the key is given, React will re-render every card from scratch, which leads to an optimisation issue or a performance hit.
- Another thing to note is that in the .map function, the index (of the mapped Array), is the second prop. Now, many developers pass the index of the Array as the key for each object since the index will be unique for each object, BUT React itself says that one shouldn't use indices as keys.

Ep5 Learnings:

- Industry standard to use a "src" file and "components" file, but it is not mandatory to follow a particular structure.
- Now, there are two kinds of exports: default(can only be one) and named.
- There's a Data layer and a UI layer. Each of the frameworks like React, Angular, etc. are trying to tackle on how to make the UI layer compatible with the Data layer. 
- And for that, React uses hooks. React Hooks are nothing but normal JS utility functions.
- The special thing about React hooks(useState, etc.) is that whenever a State variable updates, React re-renders the component, making the UI layer compatible with the changing data layer. 
- It is this property of React that makes it super-fast. 
- Important concepts accompanying this hook concept are: Virtual DOM, Reconciliation Algo (or React Fiber) and Diff Algo.

Ep6 Learnings:

- The fetch() is a feature that is provided not by React or JS, but by browser. It is a browser API used to make network requests (such as HTTP requests) to retrieve data from a server or send data to a server.
   - The fetch() function itself returns a Promise that resolves to a "Response" object once the HTTP request completes successfully.
   - The "Response" object contains methods like .json() to parse the actual response data.
   - Now, what is a "Promise"? => A Promise is an object representing the eventual completion (or failure) of an asynchronous operation. When the Promise resolves, you get the Response object.
   - The Response object represents the entire response to the request, including the data, headers, and status.
- A very important thing to note is that whenever state variable updates, react triggers a reconciliation cycle i.e it re-renders the whole component.
- Shimmer UI => a visual effect commonly used in web and mobile interfaces that helps to enhance user experience by visually indicating that data is being fetched or processed in the background, rather than leaving users with a blank or static screen.
- Diff b/w JS expressions and JS statements => Expressions are evaluated while Statements are executed.
- "async" and "await" are modern JavaScript keywords used to work with asynchronous code more easily. Async declares a function to be asynchronous and await can be used inside that async function to pause the execution of that function before waiting for the execution of the line of code where it is put. "await" is used to pause the execution of the function until the Promise is resolved (or rejected).

Ep7 Learnings:

- In useEffect, if there's no dependency array, then it'll run after each and every render of the component.
- But if an empty dependency array is there, then useEffect will be called only after the initial render.
- But if the dependency array is not empty and have some dependency, then useEffect will be called only (& everytime) when that dependency changes/updates.
- The thing to keep in mind is that the useEffect will always be called after the initial render.
- Never use useState o/s of the functional component. It is always used to create a local state variable inside the functional component.
- Also, one should not create useState in an if-else statement or a for loop or any conditionals or also under any functions inside the functional component. 
- useState is meant to be created only inside the functional component and are to be placed on the top of the code i/s the functional component.
- To create a Router setup in order to load various other pages, we need to install react-router-dom npm package.
- createBrowserRouter from react-router-dom helps in creating the router config, while RouterProvider is used to provide the project the router configuration.
- Note that RouterProvider (from react-router-dom) is a component.
- rafce => to create a boiler-plate of a component quickly.
- useRouteError => it is a hook provided by react-router-dom to give us more details about the error.
- In order to make the header and footer stay intact, we need children routes and an Outlet component (which is imported from react-router-dom).
- In react, whenever we want to route to another page from one, never use anchor tags. Because once we try to move towards another page using anchor tag, the whole page gets refreshed.
- In order to not refresh the whole page, react-router-dom comes up with the Link Component. It works exactly the same as anchor component. Only difference is that <a> has an "href" prop, while <Link> has a "to" prop. Now, behind the scenes, Link is nothing but an anchor tag.
- So, Link (unlike anchor) won't reload the whole page, but just refreshes the Outlet component only. That is why React is also known as Single Page Application (SPA). Hence, while navigating to different sub-sections of the website, under React, one doesn't have to reload the whole website again and again.
- Now, there are two types of routing that Web Applications (not just React) can have => 1) Client Side Routing & 2) Server Side Routing;
- Server Side Routing is when you make a networkcall, and the .html page is coming from the Server itself.
- Client Side Routing is what React does. It has already loaded up all the components in the first go when it loaded the App component. And whenever a page is clicked to be loaded, react just loads up the required component, without making any network call. This is called Client Side Routing.
- Hence, it is just a one page and the components are getting interchanged as per the need. That is why it is called Single Page Application (SPA).